- Start Date: 2019-09-24
- HIP PR: <!-- leave this empty -->
- Tracking Issue: <!-- leave this empty -->

# Summary
[summary]: #summary

The point of software development kit (SDK) is to mitigate the friction in device-side software development. More concretely, we work to make it easy for individuals and companies with varying levels of technical expertise to evaluate, develop and deploy on the Helium Network.

# Motivation
[motivation]: #motivation

One of our main organizational objectives is to maximize adoption and usage of the Helium Network. As such, we want to reduce technological friction and facilitate the hardware product development cycle that deploying IoT solutions entails.

There are a range of use-cases, users, and hardware which make SDK conception a non-trivial effort. Use cases range from *evaluation* to *production*. Users range from *individual hobbyists* to *large professional teams* and from *embedded software novices* to *domain experts*. Hardware encompasses *every single LoRa module out there* potentially connected to any processor.

# Stakeholders
[stakeholders]: #stakeholders

* Embedded Engineering, Customer Support Engineering, Business Development, Sales

* Feedback will be gathered by sharing this RFC

# Detailed Explanation
[detailed-explanation]: #detailed-explanation

As previously mentioned, the range of user-cases, users, and hardware makes the structure of our SDK a nuanced decision. We want to do our best to address all of these with as little engineering and customer support engineering effort as possible.

The proposal here is to focus on several projects that provide different levels of support, varying from most barebones but most portable to fully-featured by hardware-targeted:

### [*LongFi Protocol C Implementation*](https://github.com/helium/longfi-device)
A portable C library which can talk to any SX126x or SX127x radio. It must be integrated by an experienced embedded developer into an existing system (HAL layer, event management, etc), but provides an asset which is portable to virtually any LoRa module and any processor and can be run in a production setting.

### *ST HAL Super Loop*
An example implementation of the LongFi Protocol C Implementation in a "super-loop" (ie: non-RTOS or event framework). This should be impelemented specifically for a STM32L0x2 chip, allowing for compatibility with [Murata's LoRa module product line](https://www.murata.com/en-us/products/connectivitymodule/lpwa/lora), but with a dependency on STM32 HAL, is theoretically portable to the entire STM32 product line. This provides an easily consummable integration example of the LongFi Protocol for experienced embedded developers, providing a template for developers to integrate LongFi into RTOSes or event frameworks. However, super-loops are not generally scalable enough for a full IoT application which needs to support multiple sensors, actuators, potentially control, while also handling a networking protocol (LongFi) which OTA would eventually depend on.

### [*LongFi-Arduino*](https://github.com/helium/longfi-arduino)
An example implementation of the LongFi Protocol C Implementation into the Arduino ecosystem. Essentially, the Arduino framework is depended on for "system" definitions (SPI, Timeouts, Pin control). This provides a good low-barrier-to-entry "Hello, World" example for unsophisticatd users as Arduino is probably the most widely known embedded library. In addition, it allows the LongFi protocol to run on any hardware that has an Arduino board definition, in theory at least; Arduino board support can be highly variable and customer requests for support of certain boards may become a resource draw. Another drawback is that the framework's API are blocking by definition, barring many avenues for power optimization. Compounded with the same lack of scalability of the "super-loop" as mentioned previously, going to production with Arduino code is essentially a non-option.

### [*HeliOS*] 
The LongFi Protocol integrated into a production ready project (For the purpose of this section, make no assumptions on language or RTOS/event framework used). This project is in stark contrast to the super-loop implementations as it should provide a scalable production solution including OTA services, in-field configuration updates, tooling for provisioning, and potentially integration with Helium backend services. Essentially, we should expect that when a customer wants to go to production as fast as possible and has no constraints on existing infrastructure, we want to encourage them to user HeliOS so that we can provide the maximum amount of support as cheaply as possible. We should provide initial implementation that support [Murata's LoRa module product line](https://www.murata.com/en-us/products/connectivitymodule/lpwa/lora), but a scalable process for supporting additional boards and architectures should be part of this design.

This project approach is similar to other module SDKs ([nRF5](https://www.nordicsemi.com/Software-and-Tools/Software/nRF5-SDK), [WICED](https://www.cypress.com/products/wiced-software), [TI-RTOS](http://www.ti.com/tool/TI-RTOS-MCU)) which provide a setup RTOS with protocol services & sensor management and OTA examples.

### [*HeliOS++*] 
The HeliOS project, as explained above, but with a major additional feature: a segregated userspace. The core of the project is written in a modern systems programming langauge, Rust, designed specifically for memory safety and high performance. It integrates the [leading Embedded Rust event framework](https://github.com/japaric/cortex-m-rtfm) for real-time event management, while implementing a segregated userspace. The design is meant to allow for a simple userspace experience, similar to Arduino, while allowing for a high-performance / low-power event management system.  but with a major design nuance, beyond the programming language selected: hardware segregation of the application via alternate thread mode and MPU implementation. 

Despite the power of this approach, there are several drawbacks to consider:
- the kernel written in Rust makes it difficult for inexperienced or entrenched C users to modify the Real-Time Event System
- the userspace implementation, although simplified and derived from TockOS, is custom



# Drawbacks
[drawbacks]: #drawbacks

- These are four distinct projects (assuming Helios++ includes Helios); it's a lot to maintain. There are many permutations of 2-3 of these that could make strategic sense


# Rationale and Alternatives
[alternatives]: #rationale-and-alternatives

These four projects each fulfill a specific use-case and user sophistication level:
- The LongFi C implementation is a must-have; obfuscating the protocol in a larger project would provide unnecessary challenges to external developers
- The super loop project is the simplest example project for LongFi C; it's a good way for us to show a  experienced devs on how the protocol should be integrated into existing infrastructure
- Arduino is familiar and easy to most; good for hobbyist experimentation
- HeliOS provides a production ready solution for developers; good for devs who have no existing infrastructure

In addition, the approach to HeliOS++ adds a major feature on top of Helios: a segregated userspace. 

This feature provides many valuable properties:

| Customer Value | Technical Reason
| ------------- |:-------------:|
| If we certify a kernel on a specific board/module, FCC certification may be streamlined for the customer| The barrier between application and kernel will makes it easy to prove the inability for a client application to abuse the radio; it may potentially be automatic even |
| Application may be written in any language, although we will primarily support C/C++ & Rust| Since application and kernel are separate binaries, we can develop the kernel in Rust while enabling any other language that compiles as an MCU binary to run in app-space |
| Application crashes can be verbose (eg: "You ran out of stack!") and even logged over-the-air| The kernel memory cannot be corrupted by application code so we can guarantee continued kernel functionality thanks to the memory-protection unit (MPU) |
| Application can be written without worrying about obstructing low-level performance | Distinct scheduling priorities and  interrupt-driven low-level drivers guarantee low-level performance |
| Application updates over-the-air (OTA) are much smaller and thus cheaper, both in power and data | Distinct scheduling priorities and  interrupt-driven low-level drivers guarantee low-level performance |Distinct boundaries between flash for application and kernel code keep seldom changing low-level code isolated by design|
| Applications are portable from system to system so migrating to new hardware platforms can be near effortless (future Helium modules) | The application communicates with the kernel via syscalls which are inherently abstract |
| Highly integrated cloud services could be available | The kernel-barrier allows us to consider growing fairly complex drivers in kernel space that provide a service like interface to userspace (such as OTA, logging) |

The core hypothesis is that in taking on the userspace overhead upfront, we can pave a single and scalable path from experimentation to production. Providing guarantees about "our code" vs "their code", it will be easy for us to determine.

In addition, we are diverging greatly from traditional embedded by adopting Rust. This is a good thing; traditional embedded has not really changed in the last few decades and a modern programming language will help us be more efficient. Writing good C takes decades of experience and heaps of varied tooling. The pinnacle of the embedded C community collaboration is pretty much Arduino/Wiring, which while it provides accessibility like never before, is deeply flawed by being blocking only. Many good engineering hours have been wasted trying to hack in performance on this API. Meanwhile, it its short lifespan, the [Embedded Rust community is flourishing](https://github.com/rust-embedded/awesome-embedded-rust) having created for example, and [a universal HAL standard](https://crates.io/crates/embedded-hal) which proves to be much more production-worth than Wiring.


# Unresolved Questions
[unresolved]: #unresolved-questions

- Do we approach all four of these projects?

- Do we pursue HeliOS++ over HeliOS, in particular?

# Deployment Impact
[deployment-impact]: #deployment-impact

There is currently nothing deployed to this effect. 

# Success Metrics
[success-metrics]: #success-metrics

Incoming demo on HeliOS++ will contrast a "Arduino app", compiled in traditional Arduino context vs [detox-rs](https://github.com/helium/detox-rs). We will compare:
- total binary size
- "application" binary size in HeliOS++ vs Arduino binary
- power usage
- speed

In addition, an example of migration from blocking to asyncronous API will be presented.
